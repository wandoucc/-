{"_id":"2f6ab8515fe846c90097f44606e1e14a","id":1.0,"second_id":1.609057993066E+12,"title":"浏览器页面有哪三层构成，分别是什么，作用是什么?","type":"HTML","_openid":"","company":"未知","detail":"<p><strong>构成</strong>：结构层、表示层、行为层 </p>\n<p><strong>分别</strong>：HTML、CSS、JavaScript </p>\n<p><strong>作用</strong>：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</p>\n","fister_id":1.608204326915E+12}
{"_id":"73f70d5c5fe846ec00a0626601c65cf6","_openid":"","company":"未知","detail":"<h3 id=\"优点：\">优点：</h3>\n<p>​     a、网络标准统一、HTML5本身是由W3C推荐出来的。</p>\n<p>​     b、多设备、跨平台 </p>\n<p>​     c、即时更新。</p>\n<p>​     d、提高可用性和改进用户的友好体验；</p>\n<p>​     e、有几个新的标签，这将有助于开发人员定义重要的内容； </p>\n<p>​     f、可以给站点带来更多的多媒体元素(视频和音频)；  </p>\n<p>​     g、可以很好的替代Flash和Silverlight；</p>\n<p>​     h、涉及到网站的抓取和索引的时候，对于SEO很友好； </p>\n<p>​     i、被大量应用于移动应用程序和游戏。 </p>\n<h3 id=\"缺点：\">缺点：</h3>\n<p>​     a、安全：像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket 这样的功能很容易被黑客利用，来盗取用户的信息和资料。 </p>\n<p>​     b、完善性：许多特性各浏览器的支持程度也不一样。 </p>\n<p>​     c、技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像web worker、web socket、web storage 等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战 </p>\n<p>​     d、性能：某些平台上的引擎问题导致HTML5性能低下。 </p>\n<p>​     e、浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。</p>\n<hr>\n","fister_id":1.608204326915E+12,"id":2.0,"second_id":1.609058027792E+12,"title":"HTML5的优点与缺点？","type":"HTML"}
{"_id":"85ff8afa5fe8471300bf57111e082d7a","title":"Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?","type":"HTML","_openid":"","company":"未知","detail":"<p>（1）、 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 </p>\n<p>   (2）、严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。 </p>\n<p> （3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。        </p>\n<p> （4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 </p>\n","fister_id":1.608204326915E+12,"id":3.0,"second_id":1.609058067195E+12}
{"_id":"73f70d5c5fe8478d00a06b05206f0893","type":"HTML","_openid":"","company":"未知","detail":"<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th align=\"left\">内核</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IE</td>\n<td align=\"left\">trident  最新已换成webkit</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td align=\"left\">gecko</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td align=\"left\">webkit 内核</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td align=\"left\">以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核</td>\n</tr>\n<tr>\n<td>Chrome</td>\n<td align=\"left\">Blink( 基于 webkit ， Google 与 Opera Software 共同开发 )</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://cc-1251931245.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87/image-20201227163536835.png\" alt=\"image-20201227163536835\"></p>\n","fister_id":1.608204326915E+12,"id":4.0,"second_id":1.609058188792E+12,"title":"你做的网页在哪些浏览器测试过,这些浏览器的内核分别是什么?"}
{"_id":"85ff8afa5fe847ac00bf609561c6e7f9","type":"HTML","_openid":"","company":"未知","detail":"<blockquote>\n<p> 声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</p>\n</blockquote>\n","fister_id":1.608204326915E+12,"id":5.0,"second_id":1.609058219947E+12,"title":"每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？ "}
{"_id":"9f2a34705fe847b900c2788232e0ba53","second_id":1.609058233421E+12,"title":"请你描述一下 cookies，sessionStorage 和 localStorage 的区别?","type":"HTML","_openid":"","company":"未知","detail":"<p><strong>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</strong></p>\n<p>区别：</p>\n<h3 id=\"cookie\">Cookie</h3>\n<ul>\n<li><p>每个域名存储量比较小（各浏览器不同，大致 4K ）</p>\n</li>\n<li><p>所有域名的存储量有限制（各浏览器不同，大致 4K ）</p>\n</li>\n<li><p>有个数限制（各浏览器不同</p>\n</li>\n<li><p>会随请求发送到服务器</p>\n</li>\n</ul>\n<h3 id=\"localstorage\">LocalStorage</h3>\n<ul>\n<li><p>永久存储</p>\n</li>\n<li><p>单个域名存储量比较大（推荐 5MB ，各浏览器不同）</p>\n</li>\n<li><p>总体数量无限制</p>\n</li>\n</ul>\n<h3 id=\"sessionstorage\">SessionStorage</h3>\n<ul>\n<li><p>只在 Session 内有效</p>\n</li>\n<li><p>存储量更大（推荐没有限制，但是实际上各浏览器也不同</p>\n</li>\n</ul>\n","fister_id":1.608204326915E+12,"id":6.0}
{"_id":"eb0c51035fe8482c00bdaf41359d588a","company":"未知","detail":"<p>两者都是外部引用CSS的方式，但是存在一定的区别：</p>\n<p><strong>区别1：</strong>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。</p>\n<p><strong>区别2：</strong>link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。</p>\n<p><strong>区别3：</strong>link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。</p>\n<p><strong>区别4：</strong>link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。</p>\n","fister_id":1.608204326915E+12,"id":7.0,"second_id":1.609058348592E+12,"title":"link和@import的区别?","type":"HTML","_openid":""}
{"_id":"a8831daa5fe84b8200de506a1b8b6e06","id":8.0,"second_id":1.609059201855E+12,"title":"HTML全局属性(global attribute)有哪些?","type":"HTML","_openid":"","company":"未知","detail":"<p><strong>class</strong>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 </p>\n<p><strong>contenteditable</strong>: 指定元素内容是否可编辑 </p>\n<p><strong>contextmenu</strong>: 自定义鼠标右键弹出菜单内容</p>\n<p><strong>data-</strong>: 为元素增加自定义属性 </p>\n<p><strong>dir</strong>: 设置元素文本方向 </p>\n<p><strong>draggable</strong>: 设置元素是否可拖拽 </p>\n<p><strong>dropzone</strong>: 设置元素拖放类型： </p>\n<p><strong>copy, move, link hidden</strong>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</p>\n<p> <strong>id</strong>: 元素id，文档内唯一</p>\n<p> <strong>lang</strong>: 元素内容的的语言</p>\n<p> <strong>spellcheck</strong>: 是否启动拼写和语法检查</p>\n<p> <strong>style</strong>: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 </p>\n<p> <strong>title</strong>: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化</p>\n","fister_id":1.608204326915E+12}
{"_id":"2f6ab8515fe84b95009838004842ab37","_openid":"","company":"未知","detail":"<p><strong>target这个属性指定所链接的页面在浏览器窗口中的打开方式。</strong></p>\n<p><strong>它的参数值主要有：</strong></p>\n<p>a、 _blank ：在新浏览器窗口中打开链接文件</p>\n<p>b、 _parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。</p>\n<p>c、 _self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。但是我不太理解。</p>\n<p>d、 _top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。</p>\n","fister_id":1.608204326915E+12,"id":9.0,"second_id":1.609059221186E+12,"title":"说说超链接target属性的取值和作用？","type":"HTML"}
{"_id":"9f2a34705fe84ba400c2bf7920534f21","title":"如何实现浏览器内多个标签页之间的通信?","type":"HTML","_openid":"","company":"未知","detail":"<p><strong>WebSocket、 SharedWorker ；</strong></p>\n<p><strong>也可以调用localstorage、 cookies 等本地存储方式；</strong></p>\n<p><strong>localstorage另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，</strong></p>\n<p><strong>我们通过监听事件，控制它的值来进行页面信息通信；</strong></p>\n<p><strong>注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常；</strong></p>\n","fister_id":1.608204326915E+12,"id":10.0,"second_id":1.609059236536E+12}
{"_id":"98bb04175fe84bb3009e3c4f22869266","detail":"<p>title属性没有明确意义只表示是个标题， H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响；</p>\n<p>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时： <strong> 会重读，而 <B> 是展示强调内容。</p>\n<p>i内容展示为斜体， em 表示强调的文本；</p>\n<p><strong>应该准确使用语义样式标签, 但不能滥用 , 如果不能确定时首选使用自然样式标签。</strong></p>\n","fister_id":1.608204326915E+12,"id":11.0,"second_id":1.609059251101E+12,"title":"title与h3的区别、b与strong的区别、i与em的区别？","type":"HTML","_openid":"","company":"未知"}
{"_id":"a8831daa5fe84bd600de567b799de5d1","_openid":"","company":"未知","detail":"<pre><code class=\"language-html\">&lt;divstyle=&quot;width:100%;height:1px;background-color:black&quot;&gt;&lt;/div&gt;</code></pre>\n","fister_id":1.608204326915E+12,"id":12.0,"second_id":1.609059285541E+12,"title":"实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？","type":"HTML"}
{"_id":"a8831daa5fe84be200de574b699c755a","second_id":1.609059298179E+12,"title":"HTML5标签的作用?(用途)","type":"HTML","_openid":"","company":"未知","detail":"<p>a、使Web页面的内容更加有序和规范</p>\n<p>b、使搜索引擎更加容易按照HTML5规则识别出有效的内容 </p>\n<p>c、使Web页面更接近于一种数据字段和表</p>\n","fister_id":1.608204326915E+12,"id":13.0}
{"_id":"73f70d5c5fe84bf900a0b2d26a3c7a31","id":14.0,"second_id":1.609059321394E+12,"title":"img的title和alt有什么区别？","type":"HTML","_openid":"","company":"未知","detail":"<blockquote>\n<p>Alt 用于图片无法加载时显示 Title 为该属性提供信息，通常当鼠标滑动到元素上的时候显示</p>\n</blockquote>\n","fister_id":1.608204326915E+12}
{"_id":"73f70d5c5fe84c1600a0b42e20ca89dc","_openid":"","company":"未知","detail":"<p><strong>组成</strong>：表单标签、表单域、表单按钮</p>\n<p><strong>a、表单标签</strong>：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。</p>\n<p><strong>b、表单域</strong>：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。</p>\n<p><strong>c、表单按钮</strong>：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。</p>\n<p><strong>主要用途</strong>：表单在网页中主要负责数据采集的功能，和向服务器传送数据。</p>\n","fister_id":1.608204326915E+12,"id":15.0,"second_id":1.609059350371E+12,"title":"表单的基本组成部分有哪些，表单的主要用途是什么？","type":"HTML"}
{"_id":"9f2a34705fe84c2800c2c8da64b80e04","detail":"<blockquote>\n<p> (1)、 get 是从服务器上获取数据， post 是向服务器传送数据。</p>\n</blockquote>\n<blockquote>\n<p>(2)、 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。</p>\n</blockquote>\n<blockquote>\n<p>(3)、对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。</p>\n</blockquote>\n<blockquote>\n<p>(4)、 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。</p>\n</blockquote>\n<blockquote>\n<p>(5)、 get 安全性低， post 安全性较高。</p>\n</blockquote>\n","fister_id":1.608204326915E+12,"id":16.0,"second_id":1.609059367985E+12,"title":"表单提交中Get和Post方式的区别？","type":"HTML","_openid":"","company":"未知"}
{"_id":"9f2a34705fe84c3800c2c9d33b1e5fe4","type":"HTML","_openid":"","company":"未知","detail":"<p>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作，</p>\n<pre><code class=\"language-html\">&lt;canvas id=” canvas1 ″ width= ” 300 ″ height= ” 100 ″ &gt;&lt;/canvas&gt;</code></pre>\n","fister_id":1.608204326915E+12,"id":17.0,"second_id":1.609059384335E+12,"title":"HTML5 Canvas 元素有什么用？"}
{"_id":"2f6ab8515fe84c4a009841850249cdc1","fister_id":1.608204326915E+12,"id":18.0,"second_id":1.609059402253E+12,"title":"HTML5 中如何嵌入视频？","type":"HTML","_openid":"","company":"未知","detail":"<p>和音频类似，HTML5 支持 MP4 、 WebM 和 Ogg 格式的视频，下面是简单示例：</p>\n<pre><code class=\"language-html\">&lt;video width=” 450 ″ height= ” 340 ″ controls&gt;\n  &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;\n   Your browser does’ nt support video embedding feature.\n&lt;/video&gt;</code></pre>\n"}
{"_id":"85ff8afa5fe8533f00c038f572ada602","type":"CSS","_openid":"","company":"未知","detail":"<p>a、标准的css盒子模型：宽度=内容的宽度+边框的宽度+加上内边框的宽度\nb、网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。\nc、这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。</p>\n","fister_id":1.608204363094E+12,"id":1.0,"second_id":1.609061182659E+12,"title":"解释一下CSS的盒子模型？"}
{"_id":"eb0c51035fe8535200be836c72b20035","second_id":1.609061202395E+12,"title":"列出display的值并说明他们的作用？","type":"CSS","_openid":"","company":"未知","detail":"<p><strong>display：默认值：inline</strong>\n<strong>none：</strong> 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间 \n<strong>inline：</strong> 指定对象为内联元素。 \n<strong>block：</strong> 指定对象为块元素。 \nlist-item： 指定对象为列表项目。 \n<strong>inline-block：</strong> 指定对象为内联块元素。（CSS2） \n<strong>table：</strong> 指定对象作为块元素级的表格。类同于html标签<table>（CSS2） \n<strong>inline-table</strong>： 指定对象作为内联元素级的表格。类同于html标签<table>（CSS2） \n<strong>box</strong>： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） \n<strong>inline-box</strong>： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） \n<strong>flexbox</strong>： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） \n<strong>flex</strong>： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） \n<strong>inline-flex</strong>： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）</p>\n","fister_id":1.608204363094E+12,"id":2.0}
{"_id":"9f2a34705fe8536500c352ef645a3a2c","id":3.0,"second_id":1.609061221442E+12,"title":"请列举几种清除浮动的方法(至少两种)?","type":"CSS","_openid":"","company":"未知","detail":"<p><strong>(1)、父级div定义 height</strong> \n原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 \n优点：简单、代码少、容易掌握 \n缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 \n建议：不推荐使用，只建议高度固定的布局时使用\n<strong>(2)、结尾处加空div标签 clear:both</strong> \n原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 \n优点：简单、代码少、浏览器支持好、不容易出现怪问题 \n缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 \n建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 \n<strong>(3)、父级div定义 伪类:after 和 zoom</strong> \n原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 \n优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） \n缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。\n建议：推荐使用，建议定义公共类，以减少CSS代码。\n<strong>(4)、父级div定义 overflow:hidden</strong> \n原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 \n优点：简单、代码少、浏览器支持好 \n缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 \n建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 \n<strong>(5)、父级div定义 overflow:auto</strong> \n原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 \n优点：简单、代码少、浏览器支持好 \n缺点：内部宽高超过父级div时，会出现滚动条。 \n建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。</p>\n","fister_id":1.608204363094E+12}
{"_id":"9f2a34705fe8536f00c353857302a896","company":"未知","detail":"<p><strong>优雅降级：</strong> Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>\n<p><strong>渐进增强：</strong> 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>\n","fister_id":1.608204363094E+12,"id":4.0,"second_id":1.609061231246E+12,"title":"什么叫优雅降级和渐进增强？","type":"CSS","_openid":""}
{"_id":"98bb04175fe85385009eb0bc284d10fa","fister_id":1.608204363094E+12,"id":5.0,"second_id":1.609061252978E+12,"title":"为什么要初始化CSS样式？","type":"CSS","_openid":"","company":"未知","detail":"<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。\n最简单的初始化方法就是：</p>\n<pre><code class=\"language-css\"> * {padding: 0; margin: 0;}</code></pre>\n"}
{"_id":"85ff8afa5fe853a700c03ffe3084c660","id":6.0,"second_id":1.609061287071E+12,"title":"谈谈你对CSS中刻度的认识？","type":"CSS","_openid":"","company":"未知","detail":"<p><strong>在CSS中刻度是用于设置元素尺寸的单位。</strong>\na、特殊值0可以省略单位。例如：margin:0px可以写成margin:0 \nb、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。 \nc、长度单位包括：相对单位和绝对单位。 \n相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin \n绝对长度单位有： cm, mm, q, in, pt, pc, px\n绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px\n<strong>文本相对长度单位：em</strong>\n相对长度单位是相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数)</p>\n<pre><code class=\"language-css\">body { font-size: 14px; }\nh1 { font-size: 16px; }\n.size1 p { font-size: 1em; }\n.size2 p { font-size: 2em; }\n.size3 p { font-size: 3em; }</code></pre>\n<p><strong>文本相对长度单位：rem</strong>\nrem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数\n只相对于根元素的大小\n浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。</p>\n","fister_id":1.608204363094E+12}
{"_id":"a8831daa5fe853b200df00784b27f313","id":7.0,"second_id":1.609061298492E+12,"title":"请你说说box-sizing属性的的用法？","type":"CSS","_openid":"","company":"未知","detail":"<p>设置或检索对象的盒模型组成模式</p>\n<p><strong>a、box-sizing:content-box：</strong> padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin ) 此属性表现为标准模式下的盒模型。</p>\n<p><strong>b、box-sizing:border-box：</strong> padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。</p>\n","fister_id":1.608204363094E+12}
{"_id":"98bb04175fe853bf009eb3e9596a80eb","id":8.0,"second_id":1.609061310772E+12,"title":"说说隐藏元素的方式有哪些？","type":"CSS","_openid":"","company":"未知","detail":"<p>a、使用CSS的display:none，不会占有原来的位置\nb、使用CSS的visibility:hidden，会占有原来的位置\nc、使用HTML5中的新增属性hidden=&quot;hidden&quot;，不会占有原来的位置</p>\n","fister_id":1.608204363094E+12}
{"_id":"eb0c51035fe853d000be8b2c5ad06d27","company":"未知","detail":"<h3 id=\"1、什么是bfc与ifc\">(1)、什么是BFC与IFC</h3>\n<p>a、BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。</p>\n<p>b、BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。</p>\n<p>c、在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。</p>\n<h3 id=\"2、如何产生bfc\">(2)、如何产生BFC</h3>\n<p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：\na、float的值不为none\nb、overflow的值不为visible\nc、display的值为table-cell, table-caption, inline-block中的任何一个\nd、position的值不为relative和static</p>\n<p>CSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。</p>\n<h3 id=\"3、bfc的作用与特点\">(3)、BFC的作用与特点</h3>\n<p>a、不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖</p>\n<p>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。</p>\n","fister_id":1.608204363094E+12,"id":9.0,"second_id":1.609061328411E+12,"title":"谈谈你对BFC与IFC的理解？(是什么，如何产生，作用)","type":"CSS","_openid":""}
{"_id":"eb0c51035fe853e000be8c3623f7eda2","id":10.0,"second_id":1.609061344069E+12,"title":"说说你对页面中使用定位(position)的理解？","type":"CSS","_openid":"","company":"未知","detail":"<p>position：static | relative | absolute | fixed | center | page | sticky\n默认值：static，center、page、sticky是CSS3中新增加的值。\n<strong>(1)、static</strong>\n可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。\n<strong>(2)、relative</strong>\n相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。\n<strong>(3)、absolute</strong>\na、绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。\nb、元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。\n<strong>(4)、fixed</strong>\n固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。\n<strong>(5)、center</strong>\n与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）\n<strong>(6)、page</strong>\n与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）\n<strong>(7)、sticky</strong>\n对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3）</p>\n","fister_id":1.608204363094E+12}
{"_id":"2f6ab8515fe853eb0098b6913cf7bb3c","title":"如何解决多个元素重叠问题？","type":"CSS","_openid":"","company":"未知","detail":"<h3 id=\"z-index属性\">z-index属性</h3>\n<p>语法：z-index: auto | <integer>\n默认值：auto\n适用于：定位元素。即定义了position为非static的元素\n取值：\nauto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。 \n整数： 用整数值来定义堆叠级别。可以为负值。 说明：\n检索或设置对象的层叠顺序。 \nz-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。 \n当多个元素层叠在一起时，数字大者将显示在上面。</p>\n","fister_id":1.608204363094E+12,"id":11.0,"second_id":1.609061355014E+12}
{"_id":"2424fa985fe853fe00aa933c5af3974f","fister_id":1.608978114378E+12,"id":1.0,"second_id":1.609061374151E+12,"title":"TCP和UDP的区别","type":"安全","_openid":"","company":"未知","detail":"<p>1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。</p>\n<p>（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p>\n<p>（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</p>\n<p>（4）TCP只能是1对1的，UDP支持1对1,1对多。</p>\n<p>（5）TCP的首部较大为20字节，而UDP只有8字节。</p>\n<p>（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。</p>\n"}
{"_id":"2424fa985fe8541100aa94746e0545d7","id":2.0,"second_id":1.609061393121E+12,"title":"介绍知道的http返回的状态码","type":"安全","_openid":"","company":"未知","detail":"<p>100  Continue  继续。客户端应继续其请求</p>\n<p>101  Switching Protocols  切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p>\n<p>200  OK  请求成功。一般用于GET与POST请求</p>\n<p>201  Created  已创建。成功请求并创建了新的资源</p>\n<p>202  Accepted  已接受。已经接受请求，但未处理完成</p>\n<p>203  Non-Authoritative Information  非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p>\n<p>204  No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p>\n<p>205  Reset Content  重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p>\n<p>206  Partial Content  部分内容。服务器成功处理了部分GET请求</p>\n<p>300  Multiple Choices  多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p>\n<p>301  Moved Permanently  永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p>\n<p>302  Found  临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>\n<p>303  See Other  查看其它地址。与301类似。使用GET和POST请求查看</p>\n<p>304  Not Modified  未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>\n<p>305  Use Proxy  使用代理。所请求的资源必须通过代理访问</p>\n<p>306  Unused  已经被废弃的HTTP状态码</p>\n<p>307  Temporary Redirect  临时重定向。与302类似。使用GET请求重定向</p>\n<p>400  Bad Request  客户端请求的语法错误，服务器无法理解</p>\n<p>401  Unauthorized  请求要求用户的身份认证</p>\n<p>402  Payment Required  保留，将来使用</p>\n<p>403  Forbidden  服务器理解请求客户端的请求，但是拒绝执行此请求</p>\n<p>404  Not Found  服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</p>\n<p>405  Method Not Allowed  客户端请求中的方法被禁止</p>\n<p>406  Not Acceptable  服务器无法根据客户端请求的内容特性完成请求</p>\n<p>407  Proxy Authentication Required  请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p>\n<p>408  Request Time-out  服务器等待客户端发送的请求时间过长，超时</p>\n<p>409  Conflict  服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</p>\n<p>410  Gone  客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p>\n<p>411  Length Required  服务器无法处理客户端发送的不带Content-Length的请求信息</p>\n<p>412  Precondition Failed  客户端请求信息的先决条件错误</p>\n<p>413  Request Entity Too Large  由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p>\n<p>414  Request-URI Too Large  请求的URI过长（URI通常为网址），服务器无法处理</p>\n<p>415  Unsupported Media Type  服务器无法处理请求附带的媒体格式</p>\n<p>416  Requested range not satisfiable  客户端请求的范围无效</p>\n<p>417  Expectation Failed  服务器无法满足Expect的请求头信息</p>\n<p>500  Internal Server Error  服务器内部错误，无法完成请求</p>\n<p>501  Not Implemented  服务器不支持请求的功能，无法完成请求</p>\n<p>502  Bad Gateway  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p>\n<p>503  Service Unavailable  由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p>\n<p>504  Gateway Time-out  充当网关或代理的服务器，未及时从远端服务器获取请求</p>\n<p>505  HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理</p>\n","fister_id":1.608978114378E+12}
{"_id":"2424fa985fe8543500aa9d1c29a8d052","second_id":1.609061429377E+12,"title":"如何画一个三角形","type":"CSS","_openid":"","company":"未知","detail":"<pre><code class=\"language-css\">div {\n    width:0px;\n    height:0px;\n    border-top:10px solid red;\n    border-right:10px solid transparent;\n    border-bottom:10px solid transparent;\n    border-left:10px solid transparent;\n}        </code></pre>\n","fister_id":1.608204363094E+12,"id":12.0}
{"_id":"eb0c51035fe8544d00be94c34d3ca0e9","company":"未知","detail":"<pre><code class=\"language-css\">display: -webkit-box\n-webkit-box-orient:vertical\n-webkit-line-clamp:3\noverflow:hidden</code></pre>\n","fister_id":1.608204363094E+12,"id":13.0,"second_id":1.609061453081E+12,"title":"多行元素的文本省略号","type":"CSS","_openid":""}
{"_id":"9f2a34705fe8545d00c364b4003597ab","company":"未知","detail":"<p>对于行内块级元素，</p>\n<p>1、父级元素设置text-alig：center，然后设置line-height和vertical-align使其垂直居中，最后设置font-size：0消除近似居中的bug</p>\n<p>2、父级元素设置display：table-cell，vertical-align：middle达到水平垂直居中</p>\n<p>3、采用绝对定位，原理是子绝父相，父元素设置position：relative，子元素设置position：absolute，然后通过transform或margin组合使用达到垂直居中效果，设置top：50%，left：50%，transform：translate（-50%，-50%）</p>\n<p>4、绝对居中，原理是当top,bottom为0时，margin-top&amp;bottom设置auto的话会无限延伸沾满空间并平分，当left，right为0时,margin-left&amp;right设置auto会无限延伸占满空间并平分，</p>\n<p>5、采用flex，父元素设置display：flex，子元素设置margin：auto</p>\n<p>6、视窗居中，vh为视口单位，50vh即是视口高度的50/100，设置margin：50vh auto 0，transform：translate(-50%)</p>\n","fister_id":1.608204363094E+12,"id":14.0,"second_id":1.609061468697E+12,"title":"有一个width300，height300，怎么实现在屏幕上垂直水平居中","type":"CSS","_openid":""}
{"_id":"eb0c51035fe8547000be974676e69eb7","type":"JS","_openid":"","company":"未知","detail":"<blockquote>\n<p>可以更改父元素的color</p>\n</blockquote>\n","fister_id":1.608204379226E+12,"id":1.0,"second_id":1.60906148828E+12,"title":"如果想要改变一个DOM元素的字体颜色，不在它本身上进行操作？"}
{"_id":"98bb04175fe85483009ebfae225358bd","id":2.0,"second_id":1.609061506797E+12,"title":"在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？","type":"JS","_openid":"","company":"未知","detail":"<p>输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部央视，内部央视，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304</p>\n","fister_id":1.608204379226E+12}
{"_id":"2424fa985fe8549300aaa3cb702aa345","_openid":"","company":"未知","detail":"<p>渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。</p>\n<h3 id=\"区别：\">区别：</h3>\n<p>功能涵盖面，js比css大</p>\n<p>实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定</p>\n<p>对帧速表现不好的低版本浏览器，css3可以做到自然降级</p>\n<p>css动画有天然事件支持</p>\n<p>css3有兼容性问题</p>\n","fister_id":1.608204379226E+12,"id":3.0,"second_id":1.609061522799E+12,"title":"关于js动画和css3动画的差异性","type":"JS"}
{"_id":"98bb04175fe85aa8009f1a75539408b9","title":"display:none和visibility:hidden的区别？","type":"CSS","_openid":"","company":"未知","detail":"<p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，</p>\n<p>就当他从来不存在。</p>\n<p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>\n","fister_id":1.608204363094E+12,"id":15.0,"second_id":1.609063079894E+12}
{"_id":"2f6ab8515fe85ae50099172b371cd9eb","id":19.0,"second_id":1.609063141211E+12,"title":"HTML与XHTML——二者有什么区别","type":"HTML","_openid":"","company":"未知","detail":"<p>最主要的不同：</p>\n<p>XHTML 元素必须被正确地嵌套。</p>\n<p>XHTML 元素必须被关闭。</p>\n<p>标签名必须用小写字母。</p>\n<p>XHTML 文档必须拥有根元素。</p>\n","fister_id":1.608204326915E+12}
{"_id":"2f6ab8515fe85b5800992e022d78d4d5","title":"线程与进程的区别","type":"JS","_openid":"","company":"未知","detail":"<ol>\n<li><p>一个程序至少有一个进程,一个进程至少有一个线程</p>\n</li>\n<li><p>线程的划分尺度小于进程，使得多线程程序的并发性高</p>\n</li>\n<li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p>\n</li>\n<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 </p>\n</li>\n<li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":4.0,"second_id":1.609063255716E+12}
{"_id":"9f2a34705fe85b7d00c3e8f85579256c","type":"JS","_openid":"","company":"未知","detail":"<p>期待的解决方案包括：</p>\n<ol>\n<li><p>文件合并</p>\n</li>\n<li><p>文件最小化/文件压缩</p>\n</li>\n<li><p>使用 CDN 托管</p>\n</li>\n<li><p>缓存的使用（多个域名来提供缓存）</p>\n</li>\n<li><p>其他</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":5.0,"second_id":1.609063292599E+12,"title":"你如何对网站的文件和资源进行优化？"}
{"_id":"a8831daa5fe85b9500dfb90e41b93d3d","_openid":"","company":"未知","detail":"<ol>\n<li><p>优化图片 </p>\n</li>\n<li><p>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） </p>\n</li>\n<li><p>优化CSS（压缩合并css，如 margin-top, margin-left...) </p>\n</li>\n<li><p>网址后加斜杠（如<a href=\"http://www.campr.com/%E7%9B%AE%E5%BD%95%EF%BC%8C%E4%BC%9A%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E7%9B%AE%E5%BD%95%E3%80%82%EF%BC%89\">www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）</a> </p>\n</li>\n<li><p>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 </p>\n</li>\n</ol>\n<p>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了） </p>\n<ol start=\"6\">\n<li>减少http请求（合并文件，合并图片）</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":6.0,"second_id":1.6090633171E+12,"title":"请说出三种减少页面加载时间的方法","type":"JS"}
{"_id":"eb0c51035fe85bac00bf17b0777b2d1c","detail":"<p>null是一个表示&quot;无&quot;的对象，转为数值时为0</p>\n<p>undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN</p>\n<p>当声明的变量还未被初始化时，变量的默认值为undefined</p>\n<p>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象</p>\n<h3 id=\"undefined表示-缺少值，就是此处应该有一个值，但是还没有定义。\">undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。</h3>\n<p>典型用法是：</p>\n<ol>\n<li><p>变量被声明了，但没有赋值时，就等于 undefined</p>\n</li>\n<li><p>调用函数时，应该提供的参数没有提供，该参数等于 undefined</p>\n</li>\n<li><p>对象没有赋值的属性，该属性的值为 undefined</p>\n</li>\n<li><p>函数没有返回值时，默认返回 undefined</p>\n</li>\n</ol>\n<h3 id=\"null表示没有对象，即该处不应该有值。\">null表示“没有对象”，即该处不应该有值。</h3>\n<p>典型用法是：</p>\n<ol>\n<li><p>作为函数的参数，表示该函数的参数不是对象</p>\n</li>\n<li><p>作为对象原型链的终点</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":7.0,"second_id":1.60906333967E+12,"title":"null和undefined的区别？","type":"JS","_openid":"","company":"未知"}
{"_id":"85ff8afa5fe85bc700c0e0674a7076bc","_openid":"","company":"未知","detail":"<ol>\n<li><p>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</p>\n</li>\n<li><p>属性和方法被加入到 this 引用的对象中</p>\n</li>\n<li><p>新创建的对象由 this 所引用，并且最后隐式的返回 this</p>\n</li>\n</ol>\n<pre><code class=\"language-js\">var obj  = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj); </code></pre>\n","fister_id":1.608204379226E+12,"id":8.0,"second_id":1.609063367255E+12,"title":"new操作符具体干了什么呢?","type":"JS"}
{"_id":"a8831daa5fe8615700e03e8c3f423a4b","company":"未知","detail":"<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。</p>\n<pre><code class=\"language-json\">{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></pre>\n","fister_id":1.608204379226E+12,"id":9.0,"second_id":1.609064791237E+12,"title":"对JSON 的了解？","type":"JS","_openid":""}
{"_id":"eb0c51035fe8617000bf8798431b60b7","_openid":"","company":"未知","detail":"<ol>\n<li><p>defer和async</p>\n</li>\n<li><p>动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）</p>\n</li>\n<li><p>按需异步载入js</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":10.0,"second_id":1.609064815594E+12,"title":"js延迟加载的方式有哪些？","type":"JS"}
{"_id":"2f6ab8515fe861800099896121d4d842","second_id":1.609064832346E+12,"title":"如何解决跨域问题?","type":"ES6","_openid":"","company":"未知","detail":"<ol>\n<li><p>jsonp（jsonp 的原理是动态插入 script 标签）</p>\n</li>\n<li><p>document.domain + iframe</p>\n</li>\n<li><p>window.name、window.postMessage</p>\n</li>\n<li><p>服务器上设置代理页面</p>\n</li>\n</ol>\n","fister_id":1.608204395773E+12,"id":1.0}
{"_id":"2f6ab8515fe8618d00998a15544f139f","fister_id":1.608204395773E+12,"id":2.0,"second_id":1.609064844736E+12,"title":"document.write和 innerHTML 的区别  ### ","type":"ES6","_openid":"","company":"未知","detail":"<h3 id=\"documentwrite-只能重绘整个页面\">document.write 只能重绘整个页面</h3>\n<h3 id=\"innerhtml-可以重绘页面的一部分\">innerHTML 可以重绘页面的一部分</h3>\n"}
{"_id":"98bb04175fe8619d009f8cb27f91673f","_openid":"","company":"未知","detail":"<p>动态改变某个类的某个方法的运行环境</p>\n","fister_id":1.608204379226E+12,"id":11.0,"second_id":1.609064860804E+12,"title":".call() 和 .apply() 的作用？","type":"JS"}
{"_id":"85ff8afa5fe861ab00c155944f23df68","title":"哪些操作会造成内存泄漏？","type":"JS","_openid":"","company":"未知","detail":"<p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>\n<p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>\n<ol>\n<li><p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p>\n</li>\n<li><p>闭包</p>\n</li>\n<li><p>控制台日志</p>\n</li>\n<li><p>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":12.0,"second_id":1.60906487499E+12}
{"_id":"2f6ab8515fe861bd00998cdd751e67a4","title":"如何判断当前脚本运行在浏览器还是node环境中？","type":"Node","_openid":"","company":"未知","detail":"<p>通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境</p>\n","fister_id":1.608204601019E+12,"id":1.0,"second_id":1.609064892784E+12}
{"_id":"a8831daa5fe861c900e0483f2c7aca6e","id":13.0,"second_id":1.609064904819E+12,"title":"javascript对象的几种创建方式","type":"JS","_openid":"","company":"未知","detail":"<ol>\n<li><p>工厂模式</p>\n</li>\n<li><p>构造函数模式</p>\n</li>\n<li><p>原型模式</p>\n</li>\n<li><p>混合构造函数和原型模式</p>\n</li>\n<li><p>动态原型模式</p>\n</li>\n<li><p>寄生构造函数模式</p>\n</li>\n<li><p>稳妥构造函数模式</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12}
{"_id":"9f2a34705fe861d700c462ca7730bc37","second_id":1.609064918881E+12,"title":"javascript继承的 6 种方法","type":"JS","_openid":"","company":"未知","detail":"<ol>\n<li><p>原型链继承</p>\n</li>\n<li><p>借用构造函数继承</p>\n</li>\n<li><p>组合继承(原型+借用构造)</p>\n</li>\n<li><p>原型式继承</p>\n</li>\n<li><p>寄生式继承</p>\n</li>\n<li><p>寄生组合式继承</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":14.0}
{"_id":"eb0c51035fe861e500bf9000421c0fa6","id":15.0,"second_id":1.609064932709E+12,"title":"ajax 的过程是怎样的","type":"JS","_openid":"","company":"未知","detail":"<ol>\n<li><p>创建XMLHttpRequest对象,也就是创建一个异步调用对象</p>\n</li>\n<li><p>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p>\n</li>\n<li><p>设置响应HTTP请求状态变化的函数</p>\n</li>\n<li><p>发送HTTP请求</p>\n</li>\n<li><p>获取异步调用返回的数据</p>\n</li>\n<li><p>使用JavaScript和DOM实现局部刷新</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12}
{"_id":"2424fa985fe861f600ab929520ed174e","fister_id":1.608978114378E+12,"id":3.0,"second_id":1.609064950133E+12,"title":"前端的安全问题？","type":"安全","_openid":"","company":"未知","detail":"<ol>\n<li><p>XSS</p>\n</li>\n<li><p>sql注入</p>\n</li>\n<li><p>CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击</p>\n</li>\n</ol>\n<p>完成CSRF需要两个步骤：</p>\n<ol>\n<li><p>登陆受信任的网站A，在本地生成 COOKIE</p>\n</li>\n<li><p>在不登出A的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站B。</p>\n</li>\n</ol>\n"}
{"_id":"2f6ab8515fe862070099912361a2b70c","company":"未知","detail":"<ol>\n<li><p>IE6 2 个并发</p>\n</li>\n<li><p>iE7 升级之后的 6 个并发，之后版本也是 6 个</p>\n</li>\n<li><p>Firefox，chrome 也是6个</p>\n</li>\n</ol>\n","fister_id":1.608204379226E+12,"id":16.0,"second_id":1.609064967012E+12,"title":"ie 各版本和 chrome 可以并行下载多少个资源","type":"JS","_openid":""}
{"_id":"eb0c51035fe8621300bf933b46bdf07f","detail":"<p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量</p>\n","fister_id":1.608204379226E+12,"id":17.0,"second_id":1.609064978671E+12,"title":"javascript里面的继承怎么实现，如何避免原型链上面的对象共享","type":"JS","_openid":"","company":"未知"}
{"_id":"2f6ab8515fe862210099928d3a582fb9","fister_id":1.608204379226E+12,"id":18.0,"second_id":1.609064993517E+12,"title":"请解释一下 JavaScript 的同源策略。","type":"JS","_openid":"","company":"未知","detail":"<h3 id=\"概念：\">概念：</h3>\n<p>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</p>\n<p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>\n<h3 id=\"为什么要有同源限制：\">为什么要有同源限制：</h3>\n<p>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p>\n"}
{"_id":"2424fa985fe8623000ab9dab39b20425","fister_id":1.608204379226E+12,"id":19.0,"second_id":1.609065007872E+12,"title":"什么是 \"use strict\"; ? 使用它的好处和坏处分别是什么？","type":"JS","_openid":"","company":"未知","detail":"<p>ECMAscript 5添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p>\n<p>设立&quot;严格模式&quot;的目的，主要有以下几个：</p>\n<ol>\n<li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>\n</li>\n<li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>\n</li>\n<li><p>提高编译器效率，增加运行速度；</p>\n</li>\n<li><p>为未来新版本的Javascript做好铺垫。</p>\n</li>\n</ol>\n<p>注：经过测试 IE6,7,8,9 均不支持严格模式。</p>\n<h3 id=\"缺点：\">缺点：</h3>\n<p>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>\n"}
{"_id":"85ff8afa5fe8625c00c167e601164431","second_id":1.609065052193E+12,"title":"写一个通用的事件侦听器函数","type":"JS","_openid":"","company":"未知","detail":"<pre><code class=\"language-js\">// event(事件)工具集，来源：github.com/markyun\nmarkyun.Event = {\n    // 页面加载完成后\n    readyEvent : function(fn) {\n        if (fn==null) {\n            fn=document;\n        }\n        var oldonload = window.onload;\n        if (typeof window.onload != &#39;function&#39;) {\n            window.onload = fn;\n        } else {\n            window.onload = function() {\n                oldonload();\n                fn();\n            };\n        }\n    },\n    // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n    // 参数： 操作的元素,事件名称 ,事件处理程序\n    addEvent : function(element, type, handler) {\n        if (element.addEventListener) {\n            //事件类型、需要执行的函数、是否捕捉\n            element.addEventListener(type, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(&#39;on&#39; + type, function() {\n                handler.call(element);\n            });\n        } else {\n            element[&#39;on&#39; + type] = handler;\n        }\n    },\n    // 移除事件\n    removeEvent : function(element, type, handler) {\n        if (element.removeEnentListener) {\n            element.removeEnentListener(type, handler, false);\n        } else if (element.detachEvent) {\n            element.detachEvent(&#39;on&#39; + type, handler);\n        } else {\n            element[&#39;on&#39; + type] = null;\n        }\n    }, \n    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)\n    stopPropagation : function(ev) {\n        if (ev.stopPropagation) {\n            ev.stopPropagation();\n        } else {\n            ev.cancelBubble = true;\n        }\n    },\n    // 取消事件的默认行为\n    preventDefault : function(event) {\n        if (event.preventDefault) {\n            event.preventDefault();\n        } else {\n            event.returnValue = false;\n        }\n    },\n    // 获取事件目标\n    getTarget : function(event) {\n        return event.target || event.srcElement;\n    },\n    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；\n    getEvent : function(e) {\n        var ev = e || window.event;\n        if (!ev) {\n            var c = this.getEvent.caller;\n            while (c) {\n                ev = c.arguments[0];\n                if (ev &amp;&amp; Event == ev.constructor) {\n                    break;\n                }\n                c = c.caller;\n            }\n        }\n        return ev;\n    }\n};</code></pre>\n","fister_id":1.608204379226E+12,"id":20.0}
{"_id":"73f70d5c5fe8626f00a213841451049f","fister_id":1.608204601019E+12,"id":2.0,"second_id":1.609065070845E+12,"title":"对Node的优点和缺点提出了自己的看法？","type":"Node","_openid":"","company":"未知","detail":"<h3 id=\"优点：\">优点：</h3>\n<ol>\n<li><p>因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</p>\n</li>\n<li><p>与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p>\n</li>\n</ol>\n<h3 id=\"缺点：\">缺点：</h3>\n<ol>\n<li><p>Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。</p>\n</li>\n<li><p>缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。</p>\n</li>\n</ol>\n"}
{"_id":"2f6ab8515fe862ae0099a0fc6e4d2571","second_id":1.609065134212E+12,"title":"js 操作获取和设置 cookie","type":"JS","_openid":"","company":"未知","detail":"<pre><code class=\"language-js\">// 创建cookie\nfunction setCookie(name, value, expires, path, domain, secure) {\n    var cookieText = encodeURIComponent(name) + &#39;=&#39; + encodeURIComponent(value);\n    if (expires instanceof Date) {\n        cookieText += &#39;; expires=&#39; + expires;\n    }\n    if (path) {\n        cookieText += &quot;; path=&quot; + path     }\n    if (domain) {\n        cookieText += &#39;; domain=&#39; + domain;\n    }\n    if (secure) {\n        cookieText += &#39;; secure&#39;;\n    }\n    document.cookie = cookieText;\n}\n// 获取cookie\nfunction getCookie(name) {\n    var cookieName = encodeURIComponent(name) + &#39;=&#39;;\n    var cookieStart = document.cookie.indexOf(cookieName);\n    var cookieValue = null;\n    if (cookieStart &gt; -1) {\n        var cookieEnd = document.cookie.indexOf(&#39;;&#39;, cookieStart);\n        if (cookieEnd == -1) {\n            cookieEnd = document.cookie.length;\n        }\n        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));\n    }\n    return cookieValue;\n}\n// 删除cookie\nfunction unsetCookie(name) {\n    document.cookie = name + &quot;= ; expires=&quot; + new Date(0);\n}\n</code></pre>\n","fister_id":1.608204379226E+12,"id":21.0}
{"_id":"98bb04175fe862ca009f9ffe138640e8","fister_id":1.608204379226E+12,"id":22.0,"second_id":1.609065161714E+12,"title":"如何获取UA","type":"JS","_openid":"","company":"未知","detail":"<pre><code class=\"language-js\">&lt;script&gt; \nfunction whatBrowser() {  \n    document.Browser.Name.value=navigator.appName;  \n    document.Browser.Version.value=navigator.appVersion;  \n    document.Browser.Code.value=navigator.appCodeName;  \n    document.Browser.Agent.value=navigator.userAgent;  \n}\n&lt;/script&gt;</code></pre>\n"}
{"_id":"eb0c51035fe862db00bfa4c9521c65a0","detail":"<pre><code class=\"language-js\">function clone(Obj) {\n    var buf;   \n    if (Obj instanceof Array) {\n        buf = [];  // 创建一个空的数组\n        var i = Obj.length;\n        while (i--) {\n            buf[i] = clone(Obj[i]);\n        }\n        return buf;\n    } else if (Obj instanceof Object){\n        buf = {};  // 创建一个空对象\n        for (var k in Obj) {  // 为这个对象添加新的属性\n            buf[k] = clone(Obj[k]);\n        }\n        return buf;\n    }else{\n        return Obj;\n    }\n}</code></pre>\n","fister_id":1.608204395773E+12,"id":3.0,"second_id":1.609065179009E+12,"title":"js对象的深度克隆代码实现","type":"ES6","_openid":"","company":"未知"}
{"_id":"73f70d5c5fe862e900a21b832b853fe0","title":"Node.js 的适用场景","type":"Node","_openid":"","company":"未知","detail":"<ol>\n<li><p>高并发</p>\n</li>\n<li><p>聊天</p>\n</li>\n<li><p>实时消息推送                              </p>\n</li>\n</ol>\n","fister_id":1.608204601019E+12,"id":3.0,"second_id":1.609065193155E+12}
{"_id":"eb0c51035fe865cf00bfde073319ba52","company":"未知","detail":"<h4 id=\"浏览器环境中\">浏览器环境中</h4>\n<p><strong>宏任务</strong>： 包括整体代码script，setTimeout，setInterval 、 I/O 操作、UI 渲染 等</p>\n<p><strong>微任务</strong>： Promise.then</p>\n<p>特别说明的是<code>new Promise里面的内容是同步执行的，像new Promise(resolve(console.log(&#39;1&#39;)))同步执行</code>，resolve之后.then进入微任务队列，具体的内容请往下继续看。</p>\n<p><strong>在浏览器环境中：</strong>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。大概就是先执行同步代码，然后就将宏任务放进宏任务队列，宏任务队列中有微任务就将其放进微任务队列，当宏任务队列执行完就检查微任务队列，微任务队列为空了就开始下一轮宏任务的执行，往复循环。 <code>宏任务 -&gt; 微任务 -&gt; 宏任务 -&gt; 微任务一直循环</code>。</p>\n<h4 id=\"node环境中v12180\">node环境中(v12.18.0)</h4>\n<p>在node环境中事件循环的机制和浏览器有些不同</p>\n<p>node中事件循环大概可以分为这几个阶段，优先级<code>idle观察者 &gt; I/O观察者 &gt; check观察者</code>。</p>\n<ul>\n<li>idle观察者： process.nextTick</li>\n<li>I/O观察者(轮询)：一般性的I/O回调，如网络，文件，数据库I/O等</li>\n<li>check观察者(检测)：setImmediate，setTimeout</li>\n</ul>\n","fister_id":1.608204379226E+12,"id":23.0,"second_id":1.609065934537E+12,"title":"事件循环机制","type":"JS","_openid":""}
{"_id":"9f2a34705fe865e900c4b2d92029136e","type":"JS","_openid":"","company":"未知","detail":"<p>防抖就是可以限制事件在一定时间内不能多次触发，比如说你疯狂按点击按钮，一顿操作猛如虎，不加防抖的话它也会跟着你疯起来，疯狂执行触发的方法。但是一旦加了防抖，无论你点击多少次，他都只会在你最后一次点击的时候才执行。 防抖常用于搜索框或滚动条等的监听事件处理，可以提高性能。</p>\n<pre><code class=\"language-js\">function debounce(fn, wait = 50) {\n    //初始化一个定时器\n    let timer\n    return function() {\n        //如果timer存在就将其清除\n        if(timer) {\n            clearTimeout(timer)\n        }\n        //重置timer\n        timer = setTimeout(() =&gt; {\n            //将入参绑定给调用对象\n            fn.apply(this, arguments)\n        }, wait)\n    }\n}</code></pre>\n","fister_id":1.608204379226E+12,"id":24.0,"second_id":1.609065960859E+12,"title":"防抖"}
{"_id":"9f2a34705fe865fd00c4b4582a9fa812","second_id":1.609065980657E+12,"title":"节流","type":"JS","_openid":"","company":"未知","detail":"<p>节流可以控制事件触发的频率，节流就跟小水管一样，如果不加节流的话，水就会哗啦啦啦啦啦啦的流出来，但是一旦加了节流阀，你就可以自己控制水的流速了，加了节流后水可以从哗啦啦啦变成滴答滴答滴答，放到我们的函数事件里面说就是可以让事件触发变慢，比如说事件触发可以让它在每一秒内只触发一次，可以提高性能。</p>\n<pre><code class=\"language-javascript\">function throttle(fn, wait) {\n    let prev = new Date()\n    return function() {\n        let now = new Date()\n        /*当下一次事件触发的时间和初始事件触发的时间的差值大于\n            等待时间时才触发新事件 */\n        if(now - prev &gt; wait) {\n            fn.apply(this, arguments)\n            //重置初始触发时间\n            prev = new Date()\n        }\n    }\n}</code></pre>\n","fister_id":1.608204379226E+12,"id":25.0}
{"_id":"9f2a34705fe8662f00c4b7fc06dde10e","type":"JS","_openid":"","company":"未知","detail":"<pre><code class=\"language-js\">function myNew(constructFn, ...args) {\n  // 创建新对象,并继承构造方法的prototype属性,\n  //把obj挂原型链上, 相当于obj.__proto__ = constructFn.prototype\n  let obj = Object.create(constructFn.prototype)\n\n  //执行构造函数，将args参数传入，主要是为了进行赋值this.name = name等操作\n  let res = constructFn.apply(obj, args)\n\n  //确保返回值是一个对象\n  return res instanceof Object ? res : obj\n}\n\nfunction Dog(name) {\n  this.name = name\n\n  this.woof = function () {\n    console.log(&quot;汪汪汪&quot;)\n  }\n  //构造函数可以返回一个对象\n  //return { a: 1 }\n}\n\nlet dog = new Dog(&quot;阿狸&quot;)\nconsole.log(dog.name) //阿狸\ndog.woof() //汪汪汪\n\nlet dog2 = myNew(Dog, &quot;大狗&quot;)\nconsole.log(dog2.name) //大狗\ndog2.woof() //汪汪汪\n</code></pre>\n","fister_id":1.608204379226E+12,"id":26.0,"second_id":1.609066030534E+12,"title":"模拟实现一个new操作符"}
{"_id":"9f2a34705fe8665200c4ba65208e27aa","detail":"<pre><code class=\"language-js\">//手写call\nlet obj = {\n  msg: &quot;我叫王大锤&quot;,\n}\n\nfunction foo() {\n  console.log(this.msg)\n}\n\n// foo.call(obj)\n//调用call的原理就跟这里一样，将函数挂载到对象上，然后在对象中执行这个函数\n// obj.foo = foo\n// obj.foo()\n\nFunction.prototype.myCall = function (thisArg, ...args) {\n  const fn = Symbol(&quot;fn&quot;) // 声明一个独有的Symbol属性, 防止fn覆盖已有属性\n  thisArg = thisArg || window // 若没有传入this, 默认绑定window对象\n  thisArg[fn] = this //this指向调用者\n  const result = thisArg[fn](...args) //执行当前函数\n  delete thisArg[fn]\n  return result\n}\n\nfoo.myCall(obj)\n</code></pre>\n","fister_id":1.608204379226E+12,"id":27.0,"second_id":1.609066065864E+12,"title":"手写Call","type":"JS","_openid":"","company":"未知"}
{"_id":"73f70d5c5fe8667400a25a8605be98a5","company":"未知","detail":"<p>Object.is在严格等于上的基础修复了一些特殊情况下的错误，比如NaN 不等于 NaN</p>\n<pre><code class=\"language-js\">function is(x, y){\n    if(x === y){\n        // 1/+0 = +Infinity  1/-0 = -Infinity 这两个是不相等的\n        // 当 x和y都等于0的时候，就对x/0和y/0做判断\n        return x !== 0 || y !== 0 || x / 0 === y / 0\n    }\n}\n</code></pre>\n<h4 id=\"和的区别和隐式数据类型转化\">==和===的区别和隐式数据类型转化</h4>\n<p>===是严格相等，左右两边不仅值要相等，类型也要相等，例如<code>&#39;1&#39;===1</code>的结果是false，因为左边是string，右边是number。</p>\n<p>==只要值相等就会返回true，而且<code>使用==时会发生隐式类型转化</code>， 在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算 。</p>\n<ul>\n<li>转成string类型：+ 字符串连接符如 <code>1 + &quot;1&quot; = &quot;11&quot;</code></li>\n<li>转成number类型： ++、--(自增自减运算符) + 、-、*、/、%(加减乘除取余算术运算符) &gt;、 &lt;、 &gt;=、 &lt;=、 ==、 !=、 ===、 !== (关系运算符)</li>\n</ul>\n<pre><code class=\"language-js\">let i = &quot;1&quot;\nconsole.log(++i) // 2</code></pre>\n","fister_id":1.608204379226E+12,"id":28.0,"second_id":1.609066099999E+12,"title":"Object.is和===的区别","type":"JS","_openid":""}
{"_id":"9f2a34705fe8669600c4bf7a6065fe9b","_openid":"","company":"未知","detail":"<pre><code class=\"language-js\">let arr = [1, 1, &quot;1&quot;, &quot;1&quot;, null, null, undefined, undefined, /a/, /a/, NaN, NaN, {}, {}, [], []]\n</code></pre>\n<p>我们先看下几种不能去掉重复的引用数据类型的写法</p>\n<pre><code class=\"language-js\">// 使用 Set\nlet res = [...new Set(arr)]\nconsole.log(res)\n</code></pre>\n<p><img src=\"https://cc-1251931245.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87/df61c7c281c34381b7158054cdc967f5~tplv-k3u1fbpfcp-watermark.image\" alt=\"img\"></p>\n<p>这种方法虽然很简洁，但是使用该种方法我们可以看到里面的引用数据类型并没有能成功去重，只能去除基本数据类型</p>\n<pre><code class=\"language-js\">//使用filter\nlet res = arr.filter((item, index) =&gt; {\n  return arr.indexOf(item) === index\n})\nconsole.log(res)</code></pre>\n<pre><code class=\"language-js\">//使用reduce\nlet res = arr.reduce((pre, cur) =&gt; {\n  return pre.includes(cur) ? pre : [...pre, cur]\n}, [])\nconsole.log(res)\n</code></pre>\n<p>使用该两种方法也和上面的方法一样，不能去掉引用数据类型。</p>\n<p>我们再来看一下如何去除引用类型的重复值</p>\n<p>利用对象的<code>hasOwnProperty</code>方法进行判断对象上是否含有该属性，如果含有则过滤掉，不含有则返回新数组中</p>\n<pre><code class=\"language-js\">let obj = {}\nlet res = arr.filter(item =&gt; {\n  if (obj.hasOwnProperty(typeof item + item)) {\n    return false\n  } else {\n    obj[typeof item + item] = true\n    return true\n  }\n})\nconsole.log(res)\n</code></pre>\n","fister_id":1.608204379226E+12,"id":29.0,"second_id":1.609066133574E+12,"title":"数组去重","type":"JS"}
{"_id":"73f70d5c5fe866b300a25e7c662030d3","title":"数组扁平化的方法","type":"JS","_openid":"","company":"未知","detail":"<pre><code class=\"language-js\">//使用ES6中的Array.prototype.flat方法\narr.flat(Infinity)</code></pre>\n<pre><code class=\"language-js\">//使用reduce的方式\nfunction arrFlat(arr) {\n  return arr.reduce((pre, cur) =&gt; {\n    return pre.concat(Array.isArray(cur) ? arrFlat(cur) : cur)\n  }, [])\n}</code></pre>\n<pre><code class=\"language-js\">//使用递归加循环的方式\nfunction arrFlat(arr) {\n  let result = []\n  arr.map((item, index) =&gt; {\n    if (Array.isArray(item)) {\n      result = result.concat(arrFlat(item))\n    } else {\n      result.push(item)\n    }\n  })\n  return result\n}</code></pre>\n<pre><code class=\"language-js\">//将数组先变成字符串，再复原 toString()\n//这种方法存在缺陷，就是数组中元素都是Number或者String类型的才能展开\nfunction arrFlat(arr) {\n    return arr.toString().split(&#39;,&#39;).map(item=&gt; +item)\n}</code></pre>\n","fister_id":1.608204379226E+12,"id":30.0,"second_id":1.60906616288E+12}
{"_id":"2424fa985fe866ce00abed435875cf81","id":31.0,"second_id":1.609066190047E+12,"title":"for循环setTimeout打印输出","type":"JS","_openid":"","company":"未知","detail":"<p>如果不采用立即执行函数或者let的形式就会直接打印出10个10，通过采取闭包或者let有了块级作用域之后就不会出现这样的问题</p>\n<pre><code class=\"language-js\">for (var i = 0; i &lt; 10; i++) {\n  (function (j) {\n    setTimeout(() =&gt; {\n      console.log(j)\n    }, 1000)\n  })(i)\n}</code></pre>\n<p>给定时器传入第三个参数, 定时器可以传多个参数给定时器函数，此处将外层的i传递给了定时器中回调函数作为参数使用。</p>\n<pre><code class=\"language-js\">for(var i = 1;i &lt;= 5; i++){\n  setTimeout(function timer(j){\n    console.log(j)\n  }, 0, i)\n}</code></pre>\n<p>用let给定块级作用域</p>\n<pre><code class=\"language-js\">for (let i = 0; i &lt; 10; i++) {\n  setTimeout(() =&gt; {\n    console.log(i)\n  }, 1000)\n}</code></pre>\n","fister_id":1.608204379226E+12}
{"_id":"73f70d5c5fe8765600a42dc6262cf915","type":"CSS","_openid":"","company":"未知","detail":"<p>qwe</p>\n","fister_id":1.608204363094E+12,"id":16.0,"second_id":1.60907016624E+12,"title":"qe"}
{"_id":"98bb04175fe8779f00a1cb41563c292a","id":1.0,"second_id":1.609070494822E+12,"title":"Vue双向数据绑定的原理","type":"Vue","_openid":"","company":"未知","detail":"<p>通过mvvm 模型视图框架实现 </p>\n<p>模型视图框架，模型可以控制视图，视图也可以改变模型，他们通过视图模型来改变的，视图模型就是他 们中间的桥梁</p>\n<p>其核心需要通过 vm 来实现 vm的作用：视图改变之后更新数据 数据改变更新视图 其有两个部分 一个是监听器(observer) 一个是解析器(compiler)</p>\n<p>监听器：在vue中监听器 主要通过 观察者模式以及 数据劫持 来实现 </p>\n<p>其观察者模式通过 发布者 -- 订阅者实现 起主导作用的是发布者发布者通过Object.defineProperty进行监听自动触发 set 函数通知订阅者 当数据发生了变化发布者通知订阅者 订阅者进行更新页面 当然订阅者不是只有一个 所以将订阅者加入到Dop容器中</p>\n<p>解析器：主要作用就是解析指令 初始化模版，绑定订阅者</p>\n<p>总结： Observer 监听器：用来监听属性的变化通知订阅者 Watcher 订阅者：收到属性的变化，然后更新视图 Compile 解析器：解析指令，初始化模版，绑定订阅者</p>\n<p><img src=\"https://cc-1251931245.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87/image-20201227200103804.png\" alt=\"image-20201227200103804\"></p>\n","fister_id":1.608204527123E+12}
{"_id":"85ff8afa5fe8782600c4017f5ebbdbff","id":2.0,"second_id":1.609070629737E+12,"title":"vue与其它框架对比的优势和劣势？","type":"Vue","_openid":"","company":"未知","detail":"<p>优势：擅长处理数据的增删改查。</p>\n<p>劣势：不利于SEO优化、不支持IE6 7 8、首屏加载慢</p>\n","fister_id":1.608204527123E+12}
{"_id":"98bb04175fe8784500a1db1018c52d79","id":3.0,"second_id":1.609070661263E+12,"title":"mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？","type":"Vue","_openid":"","company":"未知","detail":"<p>M-model模型 V-view视图 VM-view model视图模型， 模型可以控制视图，视图也可以改变模型， 他们通过视图模型（view model）来改变的，视图模型就是他们中间的桥梁。mvvm擅长处理数据的增删改查，而jquery擅长处理动画</p>\n","fister_id":1.608204527123E+12}
{"_id":"a8831daa5fe878f000e3799922ebfac5","id":4.0,"second_id":1.609070832524E+12,"title":"常用的修饰符有哪些，他们的作用.","type":"Vue","_openid":"","company":"未知","detail":"<p>1、表单修饰符：</p>\n<p>.lazy===&gt;失去光标后修改模型中的数据</p>\n<p>.number===&gt;只能输入数字</p>\n<p>.trim===&gt;去除收尾空格</p>\n<p>2、事件修饰符：</p>\n<p>.prevent===&gt;取消默认事件</p>\n<p>.stop===&gt;阻止冒泡（阻止事件传播）</p>\n<p>.self===&gt;触发元素是自己才能触发</p>\n<p>.capture===&gt;事件捕获，先触发外层盒子再触发自己</p>\n<p>3、键盘事件：</p>\n<p>.up===&gt;上键</p>\n<p>.down===&gt;下键</p>\n<p>.left===&gt;左键</p>\n<p>.right===&gt;右键</p>\n<p>.enter===&gt;回车键</p>\n","fister_id":1.608204527123E+12}
{"_id":"eb0c51035fe87b6200c28b7f31bf989f","detail":"<p>Vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM 渲染两大重要功能。</p>\n<p>注意：</p>\n<p>①：页面初始加载时只走了前四个步骤</p>\n<p>②：数据产生变化时才会执行更新步骤函数，前四部走完更新步骤才能有效果</p>\n<pre><code class=\"language-js\">// 创建之前     全都是undefined\nbeforeCreate() {   }\n// 创建完成     vue实例化完成，数据有了，但是el还是undefined\ncreated() {   }\n// 挂载之前     找到了挂载点，但是{{}}、指令等都没有被解析\nbeforeMount() {   }\n// 挂载完成     数据解析完成，页面已经加载好了，DOM节点也有了。\n开启轮播图、开启倒计时、开启定时器、ajax请求\nmounted() {   }\n// 更新之前\nbeforeUpdate() {   }\n// 更新完成\nupdated() {   }\n// 销毁之前     善后工作，清除定时器，清除倒计时\nbeforeDestroy() {   }\n// 销毁完成\ndestroyed() {   }\nvm.$destroy() 销毁 vm.$mount(el) 挂载 </code></pre>\n","fister_id":1.608204527123E+12,"id":5.0,"second_id":1.609071457938E+12,"title":"Vue的生命周期","type":"Vue","_openid":"","company":"未知"}
{"_id":"9f2a34705fe87b7e00c779bb102e8340","detail":"<p>①创建script标签    var os = document.createElement(&#39;script&#39;)\n②设置src属性     os.src=&quot;路径?cb=bbb&quot;\n③将script插入页面   document.body.appendChild(os)\n④设置回调函数     function bbb(res){ console.log(res) }</p>\n<p>注意:jsonp只支持get，不支持post</p>\n<p>使用前提：跨域、接口一定有回调函数</p>\n","fister_id":1.608204527123E+12,"id":6.0,"second_id":1.609071485996E+12,"title":"jsonp解决跨域的原理是什么?","type":"Vue","_openid":"","company":"未知"}
{"_id":"a8831daa5fe87c1800e3e12b2c045975","_openid":"","company":"未知","detail":"<p>① 如果使用{{}}，首屏会出现闪屏，用v-text解决 \n②、使用深度监听，可能会造成页面卡顿。解决：转成简单类型，进行监听</p>\n","fister_id":1.608204527123E+12,"id":7.0,"second_id":1.609071640484E+12,"title":"vue中遇到bug?","type":"Vue"}
{"_id":"73f70d5c5fe87cc900a4bb437d9740e1","company":"未知","detail":"<p>data是一个返回对象的函数，这样设计的目的是因为，组件是为了重复调用，但数据又要互相隔离。如果定义成一个对象的话，就会一变全变，所以得定义一个函数，封闭空间。实现了展示的效果一样，但数据又互相不影响。</p>\n","fister_id":1.608204527123E+12,"id":8.0,"second_id":1.609071816784E+12,"title":"组件中的data为什么必须是函数？","type":"Vue","_openid":""}
{"_id":"a8831daa5fe87ce600e3f5f61f0960a4","type":"Vue","_openid":"","company":"未知","detail":"<p>父组件通过自定义属性传值，子组件通过props接收</p>\n<pre><code class=\"language-js\">// 父组件\n&lt;v-child :info=&quot;name&quot;&gt;&lt;/v-child&gt;\n// 子组件\nexport default {\n    props:[&quot;info&quot;]}</code></pre>\n<p>1、父传子是单向数据流\n2、默认：父变，子变；子变，父不变，并且还会报错\n3、通过生命周期把父级给我值设置为我自己的msg。父变，子不变；子变，父不变，不会报错。\n4、如果想要实现父变子变；子变父变，还不报错，那么就传递一个json类型</p>\n","fister_id":1.608204527123E+12,"id":9.0,"second_id":1.609071845713E+12,"title":" 父子组件通信（父传子）"}
{"_id":"eb0c51035fe87d0300c2b0d80d374ef5","detail":"<p>子组件想要修改父组件的数据 子传父，通过自定义事件实现；父组件可以通过e获取到子组件传的值</p>\n<pre><code class=\"language-js\">// 子组件 通过事件给父组件传数据 \n//子组件通过$emit（eventName）触发事件，父组件通过$on监听事件\nexport default {\n  methods: {\n   toggle(){this.$emit(&#39;cancle&#39;,&#39;孙尚香&#39;)} }}\n// 父组件\n&lt;v-child @cancle=&quot;toggle&quot;&gt;&lt;/v-child&gt;\nmethods:{toggle(e){\n      console.log(e)}}</code></pre>\n","fister_id":1.608204527123E+12,"id":10.0,"second_id":1.60907187501E+12,"title":"子父组件通信（子传父）","type":"Vue","_openid":"","company":"未知"}
{"_id":"a8831daa5fe8806900e474086b5e81d9","company":"未知","detail":"<p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。</p>\n<p>经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</p>\n<p>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。</p>\n<p>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>\n","fister_id":1.608204566149E+12,"id":1.0,"second_id":1.609072745084E+12,"title":"调用setState之后发生了什么？","type":"React","_openid":""}
{"_id":"2f6ab8515fe880a5009c757062308b8f","type":"React","_openid":"","company":"未知","detail":"<p>简单而言，React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为createElement的调用组合。而 React Component 则是可以接收参数输入并且返回某个 React Element 的函数或者类。</p>\n","fister_id":1.608204566149E+12,"id":2.0,"second_id":1.60907280504E+12,"title":"React中Element与Component的区别是？"}
{"_id":"eb0c51035fe880bc00c3247076e4df82","fister_id":1.608204566149E+12,"id":3.0,"second_id":1.609072828016E+12,"title":"在什么情况下你会优先选择使用Class Component而不是Functional Component？","type":"React","_openid":"","company":"未知","detail":"<p>在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。</p>\n"}
{"_id":"85ff8afa5fe880e800c4f48a4e744a9b","title":"React 中 refs 的作用是什么？","type":"React","_openid":"","company":"未知","detail":"<p>this.refs.textInputRefs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。</p>\n<p>我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p>\n<pre><code class=\"language-js\">class CustomForm extends Component { \n    handleSubmit = () =&gt; {    \n        console.log(&quot;Input Value: &quot;, this.input.value)  }  \n    render () {   \n        return (\n          &lt;form onSubmit={this.handleSubmit}&gt;\n          &lt;input  type=&#39;text&#39; ref={(input) =&gt; this.input = input} /&gt;\n                &lt;button type=&#39;submit&#39;&gt;Submit&lt;/button&gt;\n            &lt;/form&gt;    )  }}</code></pre>\n<p>上述代码中的input域包含了一个ref属性，该属性声明的回调函数会接收input对应的 DOM 元素，我们将其绑定到this指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p>\n<pre><code class=\"language-js\">function CustomForm ({handleSubmit}) { \n    let inputElement  \n    return (\n        &lt;form onSubmit={() =&gt; handleSubmit(inputElement.value)}&gt;\n         &lt;input type=&#39;text&#39; ref={(input) =&gt; inputElement = input} /&gt;\n            &lt;button type=&#39;submit&#39;&gt;Submit&lt;/button&gt;&lt;/form&gt;  )}</code></pre>\n","fister_id":1.608204566149E+12,"id":4.0,"second_id":1.609072872226E+12}
{"_id":"9f2a34705fe8819e00c82eec3a80e877","_openid":"","company":"未知","detail":"<p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>\n<pre><code class=\"language-js\">render () {  \n    return (   \n        &lt;ul&gt;{this.state.todoItems.map(({task, uid}) =&gt; {                          return &lt;li key={uid}&gt;{task}&lt;/li&gt;     \n             })}&lt;/ul&gt; )} </code></pre>\n<p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p>\n","fister_id":1.608204566149E+12,"id":5.0,"second_id":1.609073053714E+12,"title":" React中keys的作用是什么？","type":"React"}
{"_id":"73f70d5c5fe881fe00a539f0499519ba","second_id":1.609073149552E+12,"title":"在生命周期中的哪一步你应该发起AJAX请求?","type":"React","_openid":"","company":"未知","detail":"<p>我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：</p>\n<p>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。</p>\n","fister_id":1.608204566149E+12,"id":6.0}
{"_id":"98bb04175fe8823600a2c5fa6a2c7928","id":7.0,"second_id":1.609073206061E+12,"title":"shouldComponentUpdate 的作用是啥以及为何它这么重要？","type":"React","_openid":"","company":"未知","detail":"<p>shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。</p>\n","fister_id":1.608204566149E+12}
{"_id":"9f2a34705fe8828500c845d853240e65","second_id":1.609073284934E+12,"title":"如何告诉 React 它应该编译生产环境版本？","type":"React","_openid":"","company":"未知","detail":"<p>通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息。</p>\n","fister_id":1.608204566149E+12,"id":8.0}
{"_id":"eb0c51035fe8854c00c399c33617101a","title":"python实现列表去重的方法","type":"Python","_openid":"","company":"未知","detail":"<p>先通过集合去重，在转列表</p>\n<p><img src=\"https://cc-1251931245.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9temo1cnQxTlhnb0RqNTNkSmJyYUdseUJ0SnVicjdlSEs1Y3NmUnNlbTRLUzA3T3RVY3lKaWJVWWJUNDBaQWRKSHVwd21FU1M4ODdWcmc4RTZqRVRac0EvNjQw\" alt=\"img\"></p>\n","fister_id":1.608204619834E+12,"id":1.0,"second_id":1.609073996371E+12}
{"_id":"a8831daa5fe8855e00e510051a0dad15","fister_id":1.608204619834E+12,"id":2.0,"second_id":1.609074014465E+12,"title":"python内建数据类型有哪些","type":"Python","_openid":"","company":"未知","detail":"<p>整型--int</p>\n<p>布尔型--bool</p>\n<p>字符串--str</p>\n<p>列表--list</p>\n<p>元组--tuple</p>\n<p>字典--dict</p>\n"}
{"_id":"73f70d5c5fe8857800a586cb57d61e37","second_id":1.609074040121E+12,"title":"Python有哪些特点和优点","type":"Python","_openid":"","company":"未知","detail":"<p>作为一门编程入门语言，Python主要有以下特点和优点：</p>\n<ul>\n<li>可解释</li>\n<li>具有动态特性</li>\n<li>面向对象</li>\n<li>简明简单</li>\n<li>开源</li>\n<li>具有强大的社区支持</li>\n</ul>\n","fister_id":1.608204619834E+12,"id":3.0}
{"_id":"98bb04175fe8864e00a318a944ef293e","detail":"<p>一、文件/文件夹管理</p>\n<pre><code class=\"language-bash\">ls 列出当前目录文件（不包括隐含文件）\nls -a 列出当前目录文件（包括隐含文件）\nls -l 列出当前目录下文件的详细信息\n\ncd .. 回当前目录的上一级目录\ncd - 回上一次所在的目录\ncd ~ 或 cd 回当前用户的宿主目录\nmkdir 目录名 创建一个目录\nrmdir 空目录名 删除一个空目录\nrm 文件名 文件名 删除一个文件或多个文件\nrm -rf 非空目录名 删除一个非空目录下的一切\n\nmv 路经/文件 /经/文件移动相对路经下的文件到绝对路经下\nmv 文件名 新名称 在当前目录下改名\nfind 路经 -name “字符串” 查找路经所在范围内满足字符串匹配的文件和目录</code></pre>\n<p>二、系统管理</p>\n<pre><code class=\"language-bash\">fdisk -l     #查看系统分区信息\nfdisk /dev/sdb     #为一块新的SCSI硬盘进行分区\nchown root /home     #把/home的属主改成root用户\nchgrp root /home     #把/home的属组改成root组</code></pre>\n<pre><code class=\"language-bash\">Useradd             #创建一个新的用户\nGroupadd 组名    #创建一个新的组\nPasswd 用户名     #为用户创建密码\nPasswd -d用户名     #删除用户密码也能登陆\nPasswd -S用户名     #查询账号密码\nUsermod -l 新用户名 老用户名     #为用户改名\nUserdel–r 用户名     #删除用户一切</code></pre>\n<pre><code class=\"language-bash\">uname -a     #查看内核版本\ncat /etc/issue     #查看ubuntu版本\nlsusb     #查看usb设备\nsudo ethtool eth0     #查看网卡状态\ncat /proc/cpuinfo     #查看cpu信息\nlshw     查看当前硬件信息\nsudo fdisk -l     #查看磁盘信息\ndf -h     #查看硬盘剩余空间\nfree -m     #查看当前的内存使用情况\nps -A     #查看当前有哪些进程\nkill 进程号(就是ps -A中的第一列的数字)或者 killall 进程名( 杀死一个进程)\nkill -9 进程号     #强制杀死一个进程</code></pre>\n<p>三、打包/解压</p>\n<pre><code class=\"language-bash\">tar -c 创建包 –x 释放包 -v 显示命令过程 –z 代表压缩包\ntar –cvf benet.tar /home/benet 把/home/benet目录打包\ntar –zcvf benet.tar.gz /mnt 把目录打包并压缩\ntar –zxvf benet.tar.gz 压缩包的文件解压恢复\ntar –jxvf benet.tar.bz2 解压缩</code></pre>\n<p>四、apt命令</p>\n<pre><code class=\"language-bash\">apt-cache search package     #搜索包\napt-cache show package     #获取包的相关信息，如说明、大小、版本等\nsudo apt-get install package     #安装包\nsudo apt-get install package - - reinstall     #重新安装包\nsudo apt-get -f install     #修复安装”-f = –fix-missing”\nsudo apt-get remove package     #删除包\nsudo apt-get remove package - - purge     #删除包，包括删除配置文件等\nsudo apt-get update     #更新源\nsudo apt-get upgrade     #更新已安装的包\nsudo apt-get dist-upgrade     #升级系统\nsudo apt-get dselect-upgrade     #使用 dselect 升级\napt-cache depends package     #了解使用依赖\napt-cache rdepends package     #是查看该包被哪些包依赖\nsudo apt-get build-dep package     #安装相关的编译环境\napt-get source package     #下载该包的源代码\nsudo apt-get clean &amp;&amp; sudo apt-get autoclean     #清理无用的包\nsudo apt-get check     #检查是否有损坏的依赖\nsudo apt-get clean     #清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包）</code></pre>\n","fister_id":1.608204637629E+12,"id":1.0,"second_id":1.609074254385E+12,"title":"常用命令","type":"Ubuntu","_openid":"","company":"未知"}
{"_id":"2424fa985fe8873600af88e918ea0836","title":"简单描述下微信小程序的相关文件类型？","type":"小程序","_openid":"","company":"未知","detail":"<ol>\n<li>wxml 模板文件，是框架设计的一套标签语言，结合基础组件、事件系统、可以构建出页面的结构</li>\n<li>wxss 样式文件，是一套样式语言，用于描述WXML的组件样式</li>\n<li>js 脚本逻辑文件，逻辑处理网络请求</li>\n<li>json 配置文件，小程序设置，如页面注册，页面标题及tabBar</li>\n<li>app.json 整个小程序的全局配置，包括：<ul>\n<li>pages:[所有页面路径]</li>\n<li>网络设置（网络超时时间）</li>\n<li>界面表现（页面注册）</li>\n<li>window:{背景色、导航样式、默认标题}</li>\n<li>底部tab等</li>\n</ul>\n</li>\n<li>app.js 监听并处理小程序的生命周期函数、声明全局变量</li>\n<li>app.wxss 全局配置的样式文件</li>\n</ol>\n","fister_id":1.60820469353E+12,"id":1.0,"second_id":1.609074485914E+12}
{"_id":"85ff8afa5fe8874600c590047edc0c00","title":" 请谈谈wxml与标准的html的异同？","type":"小程序","_openid":"","company":"未知","detail":"<ul>\n<li>都是用来描述页面的结构；</li>\n<li>都由标签、属性等构成；</li>\n<li>标签名字不一样，且小程序标签更少，单一标签更多；</li>\n<li>多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式</li>\n<li>WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览</li>\n<li>组件封装不同， WXML对组件进行了重新封装，</li>\n<li>小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。</li>\n</ul>\n","fister_id":1.60820469353E+12,"id":2.0,"second_id":1.609074502245E+12}
{"_id":"73f70d5c5fe8875500a5a93b770f651f","fister_id":1.60820469353E+12,"id":3.0,"second_id":1.609074517012E+12,"title":"请谈谈WXSS和CSS的异同？","type":"小程序","_openid":"","company":"未知","detail":"<ul>\n<li>都是用来描述页面的样子；</li>\n<li>WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改；</li>\n<li>WXSS新增了尺寸单位，WXSS 在底层支持新的尺寸单位 rpx；</li>\n<li>WXSS 仅支持部分 CSS 选择器；</li>\n<li>WXSS 提供全局样式与局部样式</li>\n<li>WXSS 不支持window和dom 文档流</li>\n</ul>\n"}
{"_id":"73f70d5c5fe8876200a5aae9158460e0","company":"未知","detail":"<ol>\n<li>将所有的接口放在统一的js文件中并导出</li>\n<li>在app.js中创建封装请求数据的方法</li>\n<li>在子页面中调用封装的请求数据</li>\n</ol>\n","fister_id":1.60820469353E+12,"id":4.0,"second_id":1.609074529486E+12,"title":"你是怎么封装微信小程序的数据请求的？","type":"小程序","_openid":""}
{"_id":"73f70d5c5fe8877900a5ae4e1fa4de24","detail":"<pre><code>大体相同，但小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData()方法！\n\n1.双向绑定：vue默认支持双向绑定，微信小程序需要借助data。\n2.取值：vue中，通过this.reason取值。小程序中，通过this.data.reason取值。\n3.定义方法：小程序使用 在app.js中定义即可，vue的方法通过写在method中进行定义。\n\n1. 去变量的时候：\n   - 小程序  wx:for = &quot;lists&quot;\n   - Vue是  v-for = &quot;item in lists&quot;\n2. 调用data模型（赋值）的时候：\n   - 小程序：this.data.item //调用  this.setData({item:1}) //赋值\n   - vue: this.item //调用  this.item =1 //赋值\n\n小程序的双向绑定实际上并不是双向绑定 如果在小程序.js文件中改变了某个变量的值 那么页面上的值并不会跟着改变 如果想要页面上的值也跟着改变的话 需要通过setData来操作 而Vue默认就是双向绑定 只改变了某个变量的值 页面上也会跟着改变</code></pre>","fister_id":1.60820469353E+12,"id":5.0,"second_id":1.609074553024E+12,"title":"请谈谈小程序的双向绑定和vue的异同？","type":"小程序","_openid":"","company":"未知"}
{"_id":"9f2a34705fe8878800c8c57961e24f4d","_openid":"","company":"未知","detail":"<ul>\n<li>onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。</li>\n<li>onShow() 页面显示/切入前台时触发，一般用来发送数据请求；</li>\n<li>onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。</li>\n<li>onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。</li>\n<li>onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。</li>\n<li>onPullDownRefresh() 下拉刷新的钩子函数 用户下拉刷新时会自动走到这个函数中</li>\n<li>onReachBottom() 上翻到底的钩子函数</li>\n</ul>\n","fister_id":1.60820469353E+12,"id":6.0,"second_id":1.609074568112E+12,"title":"请谈谈小程序的生命周期函数？","type":"小程序"}
{"_id":"9f2a34705fe8888000c8dca06c96452a","_openid":"","company":"未知","detail":"<p>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</p>\n<p>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</p>\n<p>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p>\n<p>所以总结一下：</p>\n<ul>\n<li>从构建思路来说</li>\n</ul>\n<p>gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工</p>\n<ul>\n<li>对于知识背景来说</li>\n</ul>\n<p>gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路</p>\n","fister_id":1.608977845929E+12,"id":1.0,"second_id":1.609074816496E+12,"title":"webpack与grunt、gulp的不同？","type":"工程化"}
{"_id":"73f70d5c5fe8889100a5c4f36a2b3bb9","title":"与webpack类似的工具还有哪些","type":"工程化","_openid":"oSMUE5XPRyCG9bJZOvbHh5mUdMqw","company":"未知","detail":"<p>同样是基于入口的打包工具还有以下几个主流的：</p>\n<ul>\n<li>webpack</li>\n<li>rollup</li>\n<li>parcel</li>\n</ul>\n<p><strong>从应用场景上来看：</strong></p>\n<ul>\n<li>webpack适用于大型复杂的前端站点构建</li>\n<li>rollup适用于基础库的打包，如vue、react</li>\n<li>parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果</li>\n</ul>\n<p>由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel</p>\n","fister_id":1.608977845929E+12,"id":2.0,"second_id":1.609074832986E+12}
{"_id":"a8831daa5fe888a200e5666658ce8ffa","type":"工程化","_openid":"oSMUE5XPRyCG9bJZOvbHh5mUdMqw","company":"未知","detail":"<ul>\n<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li>\n<li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li>\n<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>\n<li>image-loader：加载并且压缩图片文件</li>\n<li>babel-loader：把 ES6 转换成 ES5</li>\n<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>\n<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>\n<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>\n</ul>\n","fister_id":1.608977845929E+12,"id":3.0,"second_id":1.609074850298E+12,"title":"有哪些常见的Loader？他们是解决什么问题的？"}
{"_id":"85ff8afa5fe888b100c5b7d02c0ea76d","_openid":"oSMUE5XPRyCG9bJZOvbHh5mUdMqw","company":"未知","detail":"<ul>\n<li>define-plugin：定义环境变量</li>\n<li>commons-chunk-plugin：提取公共代码</li>\n<li>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li>\n</ul>\n","fister_id":1.608977845929E+12,"id":4.0,"second_id":1.609074864928E+12,"title":"有哪些常见的Plugin？他们是解决什么问题的？","type":"工程化"}
{"_id":"85ff8afa5fe888be00c5b8d5366e8aa1","type":"工程化","_openid":"oSMUE5XPRyCG9bJZOvbHh5mUdMqw","company":"未知","detail":"<p><strong>不同的作用</strong></p>\n<ul>\n<li><strong>Loader</strong>直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</li>\n<li><strong>Plugin</strong>直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li>\n</ul>\n<p><strong>不同的用法</strong></p>\n<ul>\n<li><strong>Loader</strong>在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li>\n<li><strong>Plugin</strong>在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li>\n</ul>\n","fister_id":1.608977845929E+12,"id":5.0,"second_id":1.609074878577E+12,"title":"Loader和Plugin的不同？"}
{"_id":"9f2a34705fe8891c00c8e9e7158b6747","fister_id":1.608977845929E+12,"id":6.0,"second_id":1.609074971227E+12,"title":"描述一下编写loader或plugin的思路？","type":"工程化","_openid":"","company":"未知","detail":"<p>Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</p>\n<p>编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</p>\n<p>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>\n"}
